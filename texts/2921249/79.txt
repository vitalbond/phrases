<div><blockquote><p>In the face of ambiguity, refuse the temptation to guess.<br>
There should be one&ndash; and preferably only one &ndash;obvious way to do it.<br>
Although that way may not be obvious at first unless you&rsquo;re Dutch.
</p></blockquote>
<div style="margin-left: 20em">
    &mdash; Tim Peters, The Zen of Python<br>
       &gt;&gt;&gt; import this
</div>
<p>While Python has numerous advantages over other languages that make me reach for it first when starting a new project, I feel the two most important are its emphasis on readability and the community belief in Tim&rsquo;s words above, &ldquo;there should be one&ndash; and preferably only one &ndash;obvious way to do it.&rdquo; While it&rsquo;s rare to stumble upon a Python coder that doesn&rsquo;t implicitly &ldquo;get&rdquo; this principle, I find that is frequently misinterpreted when I try to explain Python&rsquo;s charm to outsiders.</p>
<p>This may be because I often misquote the principle as &ldquo;the one best way&rdquo; principle. Many languages have a &ldquo;one best way&rdquo; principle. Java, for example, insists that the best way to solve any problem is object oriented programming. Similarly, prolog insists that logic programming is the best way, and Haskell programmers suggests that functional is always the way to go.</p>
<p>Python is not like this at all. Python is pragmatically multi-paradigm. Python has a long history of stealing great ideas from other languages (and, given Guido&rsquo;s genius, making them better). Python does the very opposite of insisting that there is a best way to do everything.</p>
<p>Orthogonally, I have often had my defense of this principle misinterpreted as having said, &ldquo;Python is always the best solution to any problem.&rdquo; This makes me sound arrogant and misinformed, and is patently false. I am keenly aware of Python&rsquo;s shortcomings. My day job has me pushing Python&rsquo;s limits on a regular basis, and often, it fails me. </p>
<p>No, Python is not always the best way. The &ldquo;one obvious way&rdquo; principle refers to something quite different. It&rsquo;s not about the language or its libraries at all, it&rsquo;s more about the programmer&rsquo;s mindset. Given any specific problem, there are invariably multiple ways to solve it. A Python developer will start out by assuming that one of those assorted solutions is the best solution. The goal of both the Python language and the libraries developed by the community is to make that best solution the obvious one to implement.</p>
<p>This is a form of consistency. Just as <a href="http://www.python.org/dev/peps/pep-0008/">pep-8</a> strongly encourages us to be consistent with all other Python developers in our coding style, the &ldquo;one obvious way&rdquo; principle encourages us to be consistent in our choices of algorithms, data structures, and design patterns. In an ideal world, this means that any two Python programmers, given the same problem, would write virtually the same solution. Further, the solution that they proposed would be the best possible solution for the given problem, and all other pythonistas would find it elegantly readable.</p>
<p>This never happens. However, I believe that Python programs are closer to this ideal than many (if not most) other languages. This cohesion means that Python code is often more maintainable, not just by the original developer, but by all members of the Python community.</p>
<p>Some might suggest that strict adherence to the &ldquo;one obvious way&rdquo; principle is narrow-minded and restricts experimentation. I heartily disagree. There is clearly not one best web framework in Python. There are numerous web engines available, some more suitable to specific purposes than other. And more are being written every day. I think this is because nobody strictly believes that the most obvious implementation has been found, yet. The poem says there <strong>should</strong> be one obvious way. It doesn&rsquo;t say that there always <strong>is</strong> one. The Python community as a whole is working together to find these best solutions and make them into the obvious solution. A few problems are solved. If you need an iterator, Python&rsquo;s got you covered. Others are still up in the air, as evidenced by the collection of web frameworks or packaging tools or xml parsers on pypi. Some have only been recently solved; the <a href="http://docs.python-requests.org/en/latest/">Requests</a> library is a terrific example. And still more are completely unsolved. The most obvious way I&rsquo;ve found to handle concurrency and parallelism in Python is: Use Golang. Kivy is a terrific library, but the obvious way to do Android development is still (currently) Java.</p>
<p>In summary, while the ideal of &ldquo;obviousness&rdquo; is far, far away, I believe that it is a worthy goal to pursue. I think the mindset attracts a certain kind of programmer, and that those programmers are all as delighted when they discover Python as I was almost a decade ago. I don&rsquo;t think Python is the best tool for all jobs, nor do I think it is the most enjoyable tool for all programmers. However, for those coders who like a certain kind of obvious, readable, elegance, Python is the language of choice.</p></div>